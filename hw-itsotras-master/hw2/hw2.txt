Problem 1

a) README.md is tracked and unmodified because the repo is recently cloned. 
b) fun_problem.txt is untracked because you recently created it. README.md is tracked and modified because you added an extra line to end of it. 
c) fun_problem.txt is now tracked. fun_problem.txt and README.md are both staged to be committed because you used git add README.md fun_problem.txt. 
d) fun_problem.txt and README.md both become unmodified and then modified files because you committed then edited both files.
e) README.md is now staged because you used git add README.md. fun_problem.txt is now unmodified because you used git checkout -- fun_problem.txt. fun_problem.txt became the last version
of fun_problem.txt that was committed, which had no text inside of it, so the contents of fun_problem.txt is nothing.
f) README.md is now unstaged and staged because you are modifying a staged file without using git add again.

Problem 2
a) 1) TAB

b) rm -f *.o *~ shape1 shape2 *~ will be called, and the shape1 version of $(CXX) $(CXXFLAGS) $^ -o $@ $(LIBS) will be called, with the parameters:
g++ -I. -std=c++11 -ggdb shape1.o -o shape1 ../lib 
which will call $(CXX) $(CXXFLAGS) -c  $< -o $@ with the parameters:
g++ -I. -std=c++11 -ggdb -c shape1.cpp shape.h -o shape1.o

c)The purpose of the .PHONY rule is to stop the make file from stopping if it sees another file named 'clean' or whatever you have after the .PHONY: target

d) 2. Makefile and  4.makefile

Problem 4
1) A list of strings, with each string being one consecutive step of baking a cake, and them being in the correct order. The list ensures that the strings will be in the right order. Also 
to get to the nth step in the recipe, you must complete the n-1 steps before it. We want the be able to access the order of these steps, in order to make a cake correctly. 

2) A set of strings, with each string being one TV station identification. A set would be a good option, because there can be no duplicate stations. Also, we would only want to check
if the identification already exists in this set. If it doesn't you could make a new station and add its identification to this set. Otherwise, the station would already exist.

3)A map with the players' names being the keys and the team that they're on being the values. The values can be repeated, as the teams have multiple players. The keys can't be repeated
which is why they are the players' names. You can have a player name and a team name, look up the player and the value that comes up. If it is the same as the team you were expecting, 
they are on that certain team. If the value doesn't match the team name you expect, the player isn't on that team.

4) A map with the file type as the key, and a set of the possible programs that can read/open that file type. The keys are the file types, because each file type has one set of possible programs
that can open/read it. The values are the sets of programs that can read that certain file type, because certain programs can read multiple different file types, and many different 
programs can read the same file type, hence why it is a set. Order doesn't matter.
